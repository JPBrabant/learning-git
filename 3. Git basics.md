# Git basics

## Starting a new repo

Start an empty repo from the current directory.

```Shell
git init
```

Clone a repo (from *Github*, *Azure DevOps*, ...) inside the current directory.

```Shell
git clone https://...
```

### Gitignore

The first file you put inside your repo should be a `.gitignore` from [Github](https://github.com/github/gitignore).

## The staging area

To start tracking file and to add them to the staging area use 

```Shell
git add <file1> <file2> ...
```

Unknow file (new file) will start beeing tracked by git and known files will be added to the staging area (the index).

You can use pattern like `*.css`, `.` (the current directory) or `/directory name`.

You can remove file from staging with

```Shell
git restore --staged <file>
```

Save all staged files with

```Shell
git commit -m "Message"
```

You can omit the `-m` option and it will open a text editor to write your message in. It's usefull for multiline message.

To track a delete operation in git, and to remove the file from the file system use `rm`. The delete operation wil also automaticaly be staged.

```Shell
git rm <file1> <file2> ...
```

If the file was never tracked by git, meaning it was never commited, you need to use the `force` option. Git stop you from doing that with `-f` because it will not be possible the restore the file.

Furthermore, you can mark a file for deletion but keep it in your working directory. Meaning it will be deleted for git, but it will still be on your files system.

```Shell
git rm --cached <file>
```

Move or rename a file : 

```Shell
git mv <sourceFile> <destinationFile>
```

## Undoing mistake

Undoing something in your current working directory.

```Shell
git restore <file>
```

## Getting info about your repository

This command tell you your current branch, if it is up to date with origin, and the state of all untracked and tracked files.

```Shell
git status
```

# TODO 1

git log    # Lists the commits made in that repository in reverse chronological order; that is, the most recent commits show up first

git log --pretty=oneline # Show all commit on one line (but the hash is long)

git log --pretty=format:"%h - %an, %ar : %s" # (shor hash)

git log --pretty=format:"[%h] %s %d" --graph # Graph option is usefull to see branch.

git log -S 'functionName' # Search in the code and show commit that changed the functionName. It can be any string in the code. 

git log 'path' # Path to file or directory to see only commit of those files. Sometime preceded by -- but I don't know why. 

git log --grep 'message' # Search commit that contain that string in the commit message.

# TODO 2

HEAD

HEAD^1

HEAD~2

TOOD : Check the git documentation avec reverting change.
$ git commit --amend 

Tagging a branch (if you checkout a tag, it will move HEAD)
$ git tag name-of-tag commitHash

Because tags serve as such great "anchors" in the codebase, git has a command to describe where you are relative to the closest "anchor". Not that usefull.
$ git describe <ref>

To see what you’ve changed but not yet staged
git diff 

If you want to see what you’ve staged that will go into your next commit
git diff --staged